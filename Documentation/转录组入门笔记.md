---
title: 转录组入门笔记
date: 2017-08-15
categories: 
- Linux
- R
tags:
- 转录组
- 生信
---

# 转录组入门笔记

文章来自：http://www.jianshu.com/p/b16ae34f9012及后续；生信媛公众号

笔记贡献者: hoptop

他的简书个人主页：http://www.jianshu.com/u/9ea40b5f607a

该笔记有删改和整合。仅做学习使用，版权为原作者所有。

---

## 介绍

在目前高通量测序领域，根据测序的文库类型，可以分为DNA-Seq，RNA-Seq，ChIP-Seq等。DNA-Seq又可以继续分为全基因组测序(WGS)，全外显子测序（WES）,简化基因组测序(如RAD-Seq)。 RNA-Seq也可以继续分为mRNA-Seq, lncRNA-Seq等。目前比较火的单细胞测序(single-cell Sequencing)，则是各种测序在单个细胞水平上的操作。

刚进入这个领域，你一定会迷惘，不知所措，到底要学哪一个？ 我的建议是学习RNA-Seq，尤其是差异基因座表达分析这一部分。因为在这个方面，体系趋于成熟，大部分问题都能通过搜索引擎得到解答。因此我根据自己的学习感悟，将RNA-Seq 差异基因表达分析流程分为8步进行介绍，从环境准备开始，到从文献中下载数据，还有下载参考基因组和注释信息，接着是序列比对，基因read计数，在到差异基因表达分析，最后是富集分析。中间还需要进行质量控制以及可视化。

![](https://camo.githubusercontent.com/d13d24c63d8641955d950da80deb67de989d6663/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d32362f37323535373338352e6a7067)

## 系统准备

windows10： Unbuntu on windows10

![微软的良心](http://upload-images.jianshu.io/upload_images/2013053-9c550d940817900d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

建议搭配cmder，界面更好看，用的更开心。

![img](http://mmbiz.qpic.cn/mmbiz_png/I101ibe9h7rMnVDahZrTEDu7YGYNOmx8gjaeymLoTQO4ud7Za11vaoOwtJS8uskSiaVYKliaslERBNow9SzFIgBag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

但是直接在cmder里启动ubuntu不能使用方向键，需要做一些修改，即在cmder的setting的startup的command line添加

```
%windir%\system32\bash.exe ~ -cur_console:p:n
```

![img](http://mmbiz.qpic.cn/mmbiz_png/I101ibe9h7rMnVDahZrTEDu7YGYNOmx8ghCxjHzlfHQjvjlX2AqEyf61V5rpql8dRL4HLW52xl3CV21sY7MLGIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

## 软件准备（conda）

1.下载miniconda https://conda.io/miniconda.html Linux Python2.7

```
cd src
# wget https://repo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh
# 网址可能不太好，如果出现这种情况去官网下载
bash Miniconda2-latest-Linux-x86_64.sh
```

根据提示，最后会安装到`~/miniconda2`下。
2.添加bioconda channel, 目前还没有国内源

```
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
conda config --add channels bioconda
conda config --set show_channel_urls yes
```

补充：**.给conda添加频道**

```
conda config --add channels conda-forge
conda config --add channels defaults
conda config --add channels r
conda config --add channels bioconda
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
#最后一个是换国内的镜像

#查看已经添加的channels
conda config --get channels

# copy from https://zhuanlan.zhihu.com/p/27215788
```

3.用conda安装软件sratoolkit,fastqc,hisat2,samtools,htseq-count, 与网络有着密切的关系
查询可供安装的软件, https://bioconda.github.io/recipes.html#recipes

```
conda create -n biostar sra-tools fastqc hisat2 samtools htseq
```

拓展： 了解conda的命令

注：conda只有一个问题，就是看网络条件，国内源似乎还在制作中。

上个命令运行的结果：

```shell
#
# To activate this environment, use:
# > source activate biostar
#
# To deactivate this environment, use:
# > source deactivate biostar
#
```

这里显示了创建了一个新的环境`biostar`，里面装好了分析所需要的包。如果我们要使用它，需要键入

```shell
source activate biostar # 开启该环境
source deactivate biostar # 关闭该环境
```

R语言和Rstudio就看下面的讲解。

## 软件准备（编译）

我的习惯：

- 家目录下创建src文件夹，用于存放软件包
- 家目录下创建biosoft文件夹，用于安装软件

为了提高下载速度，我们需要替换`/etc/apt/source.list`中默认镜像源。方法参考自[中国科学技术大学开源镜像站](http://mirrors.ustc.edu.cn/help/ubuntu.html)

```shell
# 备份
cd /etc/apt/
sudo cp source.list source.list.bk
# 替换
sudo sed -i 's/http/https/g' sources.list
sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' sources.list
sudo sed -i 's/security.ubuntu.com/mirrors.ustc.edu.cn/g' sources.list
# 更新
sudo apt-get update
sudo apt-get upgrade
```

选择合适的镜像站，让你的速度飞起来。

### sratookit

功能： 下载，操作，验证NCBI SRA中二代测序数据
网址：[https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software](https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=software)
步骤：

```shell
cd src
wget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.8.2-1/sratoolkit.2.8.2-1-ubuntu64.tar.gz
tar -zxvf sratoolkit.2.8.2-1-ubuntu64.tar.gz
mv sratoolkit.2.8.2-1-ubuntu64 ~/biosoft
# 加入环境变量
echo 'PATH=$PATH:~/biosoft/sratoolkit.2.8.2-1-ubuntu64/bin' >> ~/.bashrc
# 测试
prefetch -v
# 尝试下载，默认存放在家目录下的ncbi文件夹中
prefetch -c SRR390728
```

阅读官方文章进一步了解：

1. 如何开启ascp加速下载
2. vdb-config更改基本设置

### fastqc

功能： 可视化展示二代测序数据质量
网站：[http://www.bioinformatics.babraham.ac.uk/projects/fastqc/](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
步骤：

```shell
# 判断系统是否安装java
java -version
# 安装java， 请改成openjdk-9-jdk，下面的是错误演示
sudo apt install  openjdk-9-jre-headless
# 验证
java -version
# openjdk version "9-internal"
# OpenJDK Runtime Environment (build 9-internal+0-2016-04-14-195246.buildd.src)
# OpenJDK 64-Bit Server VM (build 9-internal+0-2016-04-14-195246.buildd.src, mixed mode)
# 安装fastqc
cd src
wget http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.5.zip
unzip fastqc_v0.11.5.zip
mv FastQC/ ~/biosoft/
cd ~/biosoft/FastQC/
chmod 770 fastqc
# 添加环境变量， 我用sed修改
sed -i '/^PATH/s/\(.*\)/\1:~\/biosoft\/FastQC\//' ~/.bashrc
source ~/.bashrc
fastqc -v
# FastQC v0.11.5
```

如果找不到java包

```shell
sudo add-apt-repository ppa:webupd8team/Java

sudo apt-get update

sudo apt-get install openjdk-9-jdk

sudo apt-get -f install
```

拓展：

1. 了解fastqc结果中各个图的含义
2. 掌握如何从fastqc的结果中提取数据
3. 学习sed的用法，[http://dongweiming.github.io/sed_and_awk/](http://dongweiming.github.io/sed_and_awk/)

### samtools

SAM: 存放高通量测序比对结果的标准格式
功能： Reading/writing/editing/indexing/viewing SAM/BAM/CRAM format
网站: [http://samtools.sourceforge.net/](http://samtools.sourceforge.net/)
安装：

```shell
cd src
#  prerequsite
## system requirement
sudo apt install autoconf libz-dev libbz2-dev liblzma-dev libssl-dev

### zlib2
wget http://zlib.net/zlib-1.2.11.tar.gz
tar -zxvf zlib-1.2.11.tar.gz && cd zlib-1.2.11 && make && sudo make install && cd .. && rm -rf zlib-1.2.11

### bzip2
wget http://bzip.org/1.0.6/bzip2-1.0.6.tar.gz
tar -zxvf bzip2-1.0.6.tar.gz && cd bzip2-1.0.6 && make && sudo make install && cd .. && rm -rf  bzip2-1.0.6

### curses
sudo apt-get install libncurses5-dev 

### htslib
git clone https://github.com/samtools/htslib.git
cd htslib
autoreconf

# building samtools
git clone https://github.com/samtools/samtools.git
cd samtools
autoconf -Wno-syntax
./configure 
make && make install prefix=$HOME/biosoft/samtools

## add PATH
sed  '/^PATH/s/\(.*\)/\1:~\/biosoft\/samtools\/bin/' .bashrc -i
source ~/.bashrc
samtools --help
```

顺便安装bcftools

```shell
cd src
git clone https://github.com/samtools/bcftools.git
make && make install prefix=$HOME/biosoft/bcftools
make clean
sed  '/^PATH/s/\(.*\)/\1:~\/biosoft\/bcftools\/bin/' .bashrc -i
source ~/.bashrce
bcftools -h
```

因为用的是github，所以以后更新就用下面命令

```shell
cd htslib; git pull
cd ../bcftools; git pull
make clean
make
```

吐槽： 编译的时候需要安装好多前置包，真麻烦！

### HISAT2

功能： 将测序结果比对到参考基因组上
网站： [http://ccb.jhu.edu/software/hisat2/index.shtml](http://ccb.jhu.edu/software/hisat2/index.shtml)
安装：

```shell
cd src
wget ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/downloads/hisat2-2.1.0-source.zip
unzip hisat2-2.1.0-source.zip
# 编译hisat2
cd hisat2-2.1.0
make
rm -f *.h *.cpp 
cd ../
mv hisat2-2.1.0 ~/biosoft/hisat2
# add to PATH
sed  '/^PATH/s/\(.*\)/\1:~\/biosoft\/hisat2/' ~/.bashrc -i
source ~/.bashrc
# test
hisat2 -h
```

吐槽： 居然没有make install !!!
拓展：

- HISAT2支持`--sra-acc <SRA accession number>`,也就是可以集成SRATOOLS的，但是需要安装额外包，可以看文章自己折腾。

### HTSeq

功能： 根据比对结果统计基因count

```shell
# prerequsites
sudo apt-get install python-pip
pip install --upgrade pip
sudo apt-get install build-essential python2.7-dev python-numpy python-matplotlib
## 验证， 保证无报错
python -V
## python
python
>>> import numpy 
>>> import matplotlib 

## install HTSeq
pip install htseq

## 验证
python
>>> import HTSeq
```

教程：

1. [http://www-huber.embl.de/users/anders/HTSeq/doc/tour.html#tour](http://www-huber.embl.de/users/anders/HTSeq/doc/tour.html#tour)

推荐：

1. 推荐安装一个ipython，学习ipython如何使用
2. 将软件包安装到当前用户目录下`pip install --user xxx`

### R

Ubuntu 14.04的自带R版本跟不上时代的变化，然后自己编译的坑有太多，所以先用Linux处理数据，然后在Windows下分析数据。这样就很轻松了。一些需要编译的软件包，还可以用RTools。
R：[https://cran.r-project.org/](https://cran.r-project.org/)
Rstudio： [https://www.rstudio.com/](https://www.rstudio.com/)

**二进制版本**： R官方提供了Ubuntu最新版本更新方法,如下

```
# 添加Secure APT
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9
# 添加deb到source.list
vi source.list
deb https://mirrors.ustc.edu.cn/CRAN/bin/linux/ubuntu xenial/
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe
# 更新并安装
sudo apt-get update
sudo apt-get install r-base
# (optional)如果要自己编译R
sudo apt-get install r-base-dev
```

安装之后建议修改一下R包镜像源，提高下载速度。

```
vi ~/.Rprofile
options("repos" = c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="https://mirrors.tuna.tsinghua.edu.cn/bioconductor")
```

**安装Rstudio Server**

[https://www.rstudio.com/products/rstudio/download-server/](https://www.rstudio.com/products/rstudio/download-server/)



### [安装和使用Entrez Direct](https://mp.weixin.qq.com/s?__biz=MzI1MjU5MjMzNA==&mid=2247483839&idx=1&sn=29e2c99167af93471c7c43e3929cf852&chksm=e9e0281ede97a108dc20572de83fa6827c142996e7ada52e249f8f82c74b30de3af9b4554ce3&scene=38#wechat_redirect)



### 一点经验

以后在Ubuntu安装软件之前，先保证如下被安装了。

```
## build-essential
sudo apt-get install build-essential
## java
sudo apt install  openjdk-9-jdk

## 各种包
sudo apt install autoconf libz-dev libbz2-dev liblzma-dev libssl-dev

### zlib2
wget http://zlib.net/zlib-1.2.11.tar.gz
tar -zxvf zlib-1.2.11.tar.gz && cd zlib-1.2.11 && make && sudo make install && cd .. && rm -rf zlib-1.2.11

### bzip2
wget http://bzip.org/1.0.6/bzip2-1.0.6.tar.gz
tar -zxvf bzip2-1.0.6.tar.gz && cd bzip2-1.0.6 && make && sudo make install && cd .. && rm -rf  bzip2-1.0.6

### curses
sudo apt-get install libncurses5-dev
```

- R编译需要的Java必须是完全体，所以必须是 openjdk-9-jdk，不然无限报错
- `make -i` 可以忽略系统报错，继续走下去，很多时候一点小错是没有关系的
- 如果`./configure --prefix=/path/to/where`写错了，然后最后安装的地方错了， 不能简单的把软件包挪个位置就行了，至少要把目录内的`R-3.4.1/bin/R`和`R-3.4.1/lib/R/bin/R`的路径进行修改。
- make得要好好学习，有些时候不能`./configure && make && make install prefix=/path/to/where`一套走下来,有点作者可能没有定义install




## 读文章拿到测序数据

本系列课程学习的文章是：AKAP95 regulates splicing through scaffolding RNAs and RNA processing factors. Nat Commun 2016 Nov 8;7:13347. PMID: 27824034 很容易在文章里面找到数据地址GSE81916 这样就可以下载sra文件

## 数据下载部分

第一步：在PubMeb上查找文献 [![img](https://camo.githubusercontent.com/4e2fbbc0887be1f52a40aeab391075922a11873e/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f34333432373830362e6a7067)](https://camo.githubusercontent.com/4e2fbbc0887be1f52a40aeab391075922a11873e/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f34333432373830362e6a7067)

第二步： 根据文献的method部分找到RNA-Seq是如何存放的 [![img](https://camo.githubusercontent.com/202b32d5cd76fcac03e6413030ce9dc86f56dd47/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f33363837303233352e6a7067)](https://camo.githubusercontent.com/202b32d5cd76fcac03e6413030ce9dc86f56dd47/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f33363837303233352e6a7067)

第三步： 在GEO上查找GSE81916 GEO站点： <https://www.ncbi.nlm.nih.gov/geo/> [![img](https://camo.githubusercontent.com/dc2322b074642da937dffcd14abe77294ee0f474/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39323939343532342e6a7067)](https://camo.githubusercontent.com/dc2322b074642da937dffcd14abe77294ee0f474/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39323939343532342e6a7067)

找到了NCBI的SRA工具下载所需要的SRR编号。

[![img](https://camo.githubusercontent.com/646f86d4f7512a107379a9941acfcbd6dcbad00e/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31353734353336332e6a7067)](https://camo.githubusercontent.com/646f86d4f7512a107379a9941acfcbd6dcbad00e/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31353734353336332e6a7067) [![img](https://camo.githubusercontent.com/af4900cc37f0967cdea39ac73da80b1689718bda/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f37303632333330382e6a7067)](https://camo.githubusercontent.com/af4900cc37f0967cdea39ac73da80b1689718bda/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f37303632333330382e6a7067)

GEO网址： <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE81916> 分为两个部分：

- 共同部分：<https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=>
- 变动部分：GSE81916

FTP网址<ftp://ftp-trace.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByStudy/sra/SRP/SRP075/SRP075747> 可以分为以下几个部分

- 所有SRA数据的共同部分： <ftp://ftp-trace.ncbi.nlm.nih.gov/sra/sra-instant>
- reads表示存放reads数据，在FTP可以看到另一个选项是analysis，表示分析结果
- ByStudy表示根据Study进行分类，其他还可以根据实验`ByExp`,根据Run,`ByRun`.
- sra/SRP/SRP075/SRP075747: 后面部分都是为了便于检索。

第四步：通过循环，分别用prefetch下载数据

```shell
for i in `seq 48 62`;
do
    prefetch SRR35899${i}
done
```

知识点：如何用循环批量下载数据 **注**： 数据很大，需要下载很久，这段时间去看文章所用的分析方法。

## 文章所用方法

内容主要在Bioinformatic analyses部分 **比对**：

- 比对软件：TopHat (v2.0.13)
- 参考基因组：human reference genome (GRCh37/hg19)
- GTF文件： GTF version GRCh37.70
- 只保留MQ >30的map结果
- Picard-tools (v1.126)： 计算平均插入大小(mean insert sizes)和标准差

**read count**: 软件：HTSeq v0.6.0

**差异表达分析**： DESeq (v3.0)

**差异外显子使用分析**： DEXSeq (v3.1)

**GO富集分析**：DAVID (<http://david.ncifcrf.gov/>).

**实验设计**： 样本9-15为mRNA-Seq测序结果，用于分析人类293个细胞（9-11）和小鼠ES细胞（12-15）d的AKAP95敲出影响。

## 文章到底用RNA-Seq做了那些事情

为了评估AKAP95对AS的全局影响，他们删除了人类293 cell和小鼠ES细胞，通过RNA-Seq和**DEXseq** 分析找到细胞mRNA的不同外显子使用。由于**DEXseq考虑到了生物学变异**，因此对假阳性（False discovery)有可信的控制。在 293 cell 和 ES cell中，AKAPP95 KD都导致更多的外显子使用减少，意味着APAP95通过促进外显子融合调节全局地可变剪切（AS). 他们用PCR-based assay验证了结果。

文章用了火山图展示被影响的外显子，用饼图可视化多少个外显子被下调了。Fold change is the ratio of the normalized exon level in AKAP95 KD over that in control cells. [![img](https://camo.githubusercontent.com/22c3a05abf99581d11b67298c77e1e77ecb7b719/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39383133313935322e6a7067)](https://camo.githubusercontent.com/22c3a05abf99581d11b67298c77e1e77ecb7b719/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39383133313935322e6a7067)

为了证明外显子使用(exon usage)降低不是因为**基因表达量降低导致的技术偏差**，作者从三个角度进行论证

1. 工具角度，DEXseq根据基因的总外显子信号水平标准化每个外显子信号
2. 数据分析，AKAP95 KD的细胞中那些外显子使用被影响的大部分基因，表达量没有降低，**所以**和表达量无关，还用图证明。Fold change is the ratio of the normalized exon level in AKAP95 KD over that in control cells.

![img](https://camo.githubusercontent.com/428939492597305caf4ef74af5201624491f9e38/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f313830323937352e6a7067)

3. PCR数据证实 
4. 小鼠的也是如此

确定**可变外显子使用是AKAP95的直接影响**， 他们比较了AKAP95物理靶点（基于AKAP95 RIP-Seq)和功能位点（基于mRNA-Seq)。 那些AKAP95结合到内含子的基因和外显子使用显著性变化（AKAP95 KD）的基因显著性重叠。 逻辑就是： 如果A和B有关，那么有A就有B， 没有A就没有B，且这种关系不是偶然的。 [![img](https://camo.githubusercontent.com/cb925712ea237b2a96e8aa6ef003ee326af72f08/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31383435373631352e6a7067)](https://camo.githubusercontent.com/cb925712ea237b2a96e8aa6ef003ee326af72f08/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31383435373631352e6a7067)

确定AKAP95靶点参与的生物学通路，他们用了基因本体论（GO)分析了AKAP95的功能位点和物理位点。结果揭示那些AKAP95 KD 的293细胞中那些差异外显子使用的基因，显著性的富集在chromatin/transcription regulators and RNA processing factors。那些RIP-Seq找到基因也是如此。 [![img](https://camo.githubusercontent.com/efb155145dfa20b0f739abe0c8524f99514c9d84/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f34303138323831392e6a7067)](https://camo.githubusercontent.com/efb155145dfa20b0f739abe0c8524f99514c9d84/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f34303138323831392e6a7067)

综上， AKAP95可能通过直接和间接调节染色质，转录和RNA加工调节全局基因表达。



## 了解fastq测序数据

需要用安装好的sratoolkit把sra文件转换为fastq格式的测序文件，并且用fastqc软件测试测序文件的质量！ 理解测序reads，GC含量，质量值，接头，index，fastqc的全部报告。

## 数据解压

之前下载了所有的数据，但只有样本9 ~ 15才是mRNA-Seq测序结果，其中9-11为人类293个AKAP9敲除细胞，12-15为小鼠的AKAP9敲除细胞。也就是只要解压9 ~ 15就行了，即是SRR3589956 ~ SRR3589962. 先看一篇文章[做过1000遍RNA-Seq的老司机告诉你如何翻车](https://mp.weixin.qq.com/s/xNqEP7RV7UtZU7KiYm1mXw)， 看一下事故现场，避开一些坑。 可以先用`fastq-dump -h`看一下帮助文件，分为如下几个部分：

- 输入： -A|--accession 序列号
- 处理中: Read Splitting, Full Spot Filters, Common Filters, Filters based on alignments, Filters for individual reads。 基本都是些过滤参数。不太常用
- 输出： -O|--outdir 输出文件夹， -Z|--stdout 输出到标准输出， --gzip/--bzip2 输出为压缩格式
- 多文件选项： 常用的就是--split-3
- 格式化： 分为序列， 质量等，不常用

所以基本上命令即使如下用法, 如果你觉得自己的空间够大就不需要用到`--gzip`参数。

```shell
for id in `seq 56 62`
do
    fastq-dump --gzip --split-3 -O /mnt/f/Data/RNA-Seq -A SRR35899${id}
done
```

压缩的文件不要着急解压，有很多bash命令能够直接用于压缩文件，如`zgrep`,`zcat`,`zless`,`zdiff`等。

```shell
zcat SRR3589956_1.fastq.gz | head -n 4
@SRR3589956.1 D5VG2KN1:224:C4VAYACXX:5:1101:1159:2173 length=51
GGCGAGTGTAGGGCTGGCGCTGCCGGACGCGGTGCTAGTCGCCGGATGAAG
+SRR3589956.1 D5VG2KN1:224:C4VAYACXX:5:1101:1159:2173 length=51
B<BFBFBF0BFFFBFFBBFFIF<FFI<7<<BF<FFFFFFBB<BBBBBBBBB
```

用这些z-tools能够节省大量磁盘空间。

## QC basic concept

高通量测序之所以能够能够达到如此高的通量的原因就是他把原来几十M，几百M，甚至几个G的基因组通过物理或化学的方式打算成几百bp的短序列，然后同时测序。 [![img](https://camo.githubusercontent.com/467ba58ca04ae86b21d856ebf06cdb4c9ffbb106/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f38313136303630332e6a7067)](https://camo.githubusercontent.com/467ba58ca04ae86b21d856ebf06cdb4c9ffbb106/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f38313136303630332e6a7067)

因为测序过程是边合成边测序（SBS），所以在建库的时候，短序列两段会加一些固定的碱基用于桥式PCR扩增，这些固定的碱基就是adapter(接头)。一般而言，还可以在接头加一些tag（index），用于标识这个read来自于哪个物种。目前的单细胞测序为了省钱，譬如10X genomic技术，都是在一个pool里面加多种接头。 [![img](https://camo.githubusercontent.com/64ac4ac5a5e39bedcf2c20f28d4b82b13178a395/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39313237363032312e6a7067)](https://camo.githubusercontent.com/64ac4ac5a5e39bedcf2c20f28d4b82b13178a395/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f39313237363032312e6a7067)

在测序过程中，机器会对每次读取的结果赋予一个值，用于表明它有多大把握结果是对的。从理论上都是前面质量好，后面质量差。并且在某些GC比例高的区域，测序质量会大幅度降低。

因此，我们在正式的数据分析之前需要对分析结果进行质控。Jimmy大神就发帖专门指出”要充分了解你的测序数据--论QC的重要性“，<http://www.biotrainee.com/thread-324-1-1.html> 。

### Fastq文件格式说明

FASTQ文件每个序列通常为4行，分别为：

- Line 1 begins with a '@' character and is followed by a sequence identifier and an *optional* description (like a [FASTA](https://en.wikipedia.org/wiki/FASTA_format) title line).
- Line 2 is the raw sequence letters.
- Line 3 begins with a '+' character and is *optionally* followed by the same sequence identifier (and any description) again.
- Line 4 encodes the quality values for the sequence in Line 2, and must contain the same number of symbols as letters in the sequence.

FASTQ的文件示例：

```
@DJB775P1:248:D0MDGACXX:7:1202:12362:49613 1:Y:18:ATCACG
TGCTTACTCTGCGTTGATACCACTGCTTAGATCGGAAGAGCACACGTCTGAA
+
JJJJJIIJJJJJJHIHHHGHFFFFFFCEEEEEDBD?DDDDDDBDDDABDDCA

```

**第一行序列名称** 其中第一行的命名方式在v1.4后是 "@EAS139:\136:\FC706VJ:\2:\2104:\15343:\197393 1:\Y:\18:ATCACG"

| Tag       | 描述                                       |
| --------- | ---------------------------------------- |
| DJB775P1  | the unique instrument name               |
| 248       | the run id                               |
| D0MDGACXX | the flowcell id                          |
| 7         | flowcell lane                            |
| 1202      | tile number within the flowcell lane     |
| 12362     | 'x'-coordinate of the cluster within the tile |
| 49613     | 'y'-coordinate of the cluster within the tile |
| 1         | the member of a pair, 1 or 2 *(paired-end or mate-pair reads only)* |
| Y         | Y if the read is filtered, N otherwise   |
| 18        | 0 when none of the control bits are on, otherwise it is an even number |
| ATCACG    | index sequence                           |

**在v1.4之前**`@HWUSI-EAS100R:6:73:941:1973#0/1`

| Tag           | 描述                                       |
| ------------- | ---------------------------------------- |
| HWUSI-EAS100R | the unique instrument name               |
| 6             | flowcell lane                            |
| 73            | tile number within the flowcell lane     |
| 941           | 'x'-coordinate of the cluster within the tile |
| 1973          | 'y'-coordinate of the cluster within the tile |
| #0            | index number for a multiplexed sample (0 for no indexing) |
| /1            | the member of a pair, /1 or /2 *(paired-end or mate-pair reads only)* |

** 第三行质量序列格式** 目前illumina使用的碱基质量格式为phred+33, 和Sanger的质量基本一致。

| Name                                   | ASCII character range | Offset | Quality score type | Quality score range |
| -------------------------------------- | --------------------- | ------ | ------------------ | ------------------- |
| Sanger, Illumina (versions 1.8 onward) | 33–126                | 33     | PHRED              | 0–93                |
| Solexa, early Illumina (before 1.3)    | 59–126                | 64     | Solexa             | 5–62                |
| Illumina (versions 1.3–1.7)            | 64–126                | 64     | PHRED              | 0–62                |

不同版本的碱基质量Q和碱基错误率P的关系如下 [![Relationship between Q and p](https://camo.githubusercontent.com/f50b0aed93a54f1fd3a5aa34a5148faeff10d9bc/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f362f36622f50726f626162696c6974795f6d6574726963732e7376672f36303070782d50726f626162696c6974795f6d6574726963732e7376672e706e67)](https://camo.githubusercontent.com/f50b0aed93a54f1fd3a5aa34a5148faeff10d9bc/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f362f36622f50726f626162696c6974795f6d6574726963732e7376672f36303070782d50726f626162696c6974795f6d6574726963732e7376672e706e67)

## FastQC质量报告

质量控制的软件很多，但是目前主要以fastqc为主。常见的用法：

```
fastqc seqfile1 seqfile2 .. seqfileN
常用参数：
-o： 输出路径
--extract: 输出文件是否需要自动解压 默认是--noextract
-t: 线程， 和电脑配置有关，每个线程需要250MB的内存
-c: 测序中可能会有污染， 比如说混入其他物种
-a: 接头
-q: 安静模式
```

FastQC有两种方式分析压缩的fastq文件

```
zcat SRR3589956_1.fastq.gz | fastqc -t 4 stdin
fastqc SRR3589956_1.fastq.gz

```

结果会得到一个html文件和一个zip压缩包。 [![img](https://camo.githubusercontent.com/4cceeee22fe5a04907c47945b046f959e6682d2a/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31303339323334392e6a7067)](https://camo.githubusercontent.com/4cceeee22fe5a04907c47945b046f959e6682d2a/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f31303339323334392e6a7067) 其中html文件用浏览器打开就能直观看到数据 [![img](https://camo.githubusercontent.com/e1845cb3d2ccb5e59103ec7569d9943846d32439/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f35383831343935302e6a7067)](https://camo.githubusercontent.com/e1845cb3d2ccb5e59103ec7569d9943846d32439/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f35383831343935302e6a7067)绿色表示通过，红色表示未通过，黄色表示不太好。一般而言RNA-Seq数据在sequence duplication levels 未通过是比较正常的。毕竟一个基因会大量表达，会测到很多遍。 总体看来，测序可接受。 下面这种（从FASTQC官网找到的实例）就要好好好好处理一下了

[![img](https://camo.githubusercontent.com/c4b0c73c832210339484b26371cce5788ca030dd/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f33343736353836392e6a7067)](https://camo.githubusercontent.com/c4b0c73c832210339484b26371cce5788ca030dd/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f33343736353836392e6a7067)

具体含义可以看这里： <http://jingyan.baidu.com/article/49711c6149e27dfa441b7c34.html>

由于有14个结果，如果一个一个打开过去，一定会麻烦死，最好有一种一劳永逸的方法。 知乎的青山屋主写了一篇关于multiQC的教程（[https://zhuanlan.zhihu.com/p/27646873](https://zhuanlan.zhihu.com/p/27646873%EF%BC%8C)） 介绍聚合多个QC结果进行演示的方法。

利用conda安装软件尤其简单，

```
conda install multiqc
multiqc --help

```

使用也很方便，

```
# 先获取QC结果
 ls *gz | while read id; do fastqc -t 4 $id; done
# multiqc
multiqc *fastqc.zip --pdf
#　使用multiqc  *fastqc.zip则显示的是动态交互图
```

会有一个html文件用来了解总体情况 [![img](https://camo.githubusercontent.com/540ca9081ffc5a3bbf228f21c6829109ce198949/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f37303739353430392e6a7067)](https://camo.githubusercontent.com/540ca9081ffc5a3bbf228f21c6829109ce198949/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31382f37303739353430392e6a7067)

除了用multiQC查看多个QC结果以外，还可以专门写一个脚本看**每个样本的reads数量，GC含量，Q20，Q30的比例**

### Python脚本

逻辑：

- 用python的zipfile模块打开zip文件，读取xx_data.txt的数据
- 读取每一行的数据，用正则表达式模块re，找到目标行
- 根据分隔符对每一行进行分割，进行赋值
- 由于只需要读取到>>Per base sequence quality pass这一部分，所以设置一个>>END_MODULE的计数器，数量超过2，就停止。

```
import re
import zipfile
# read the zip file
def zipReader(file):
    qcfile =  zipfile.ZipFile(file)
    data_txt = [file for file in qcfile.namelist() if re.match(".*?_data\.txt", file)][0]
    data = [bytes.decode(line) for line in qcfile.open(data_txt)]
    return data

def fastqc_summary(data):
    module_num = 0
    bases = 0
    Q20 = 0
    Q30 = 0
    for line in data:
        if re.match('Filename', line):
            filename = line.split(sep="\t")[1].strip()
        if re.match('Total Sequence', line):
            read = line.split(sep="\t")[1].strip()
        if re.match('%GC', line):
            GC = line.split(sep="\t")[1].strip()
        if re.match("[^#](.*?\t){6}",line):
            bases = bases + 1
            if float(line.split("\t")[1]) > 30:
                Q20 = Q20 + 1
                Q30 = Q30 + 1
            elif float(line.split("\t")[1]) > 20:
                Q20 = Q20 + 1

        if re.match(">>END", line) :
            module_num = module_num + 1
            if module_num >= 2:
                break
    Q20 = Q20 / bases
    Q30 = Q30 / bases
    summary = [filename, read, GC, str(Q20), str(Q30)]
    return summary

if __name__ == '__main__':
    import sys
    for arg in range(1, len(sys.argv)):
        data = zipReader(sys.argv[arg])
        summary = fastqc_summary(data)
        with open('summary.txt', 'a') as f:
            f.write('\t'.join(summary) + '\n')
```


## 了解参考基因组及基因注释

## 要求

在UCSC下载hg19参考基因组，我博客有详细说明，从gencode数据库下载基因注释文件，并且用IGV去查看你感兴趣的基因的结构，比如TP53,KRAS,EGFR等等。 作业，截图几个基因的IGV可视化结构！还可以下载ENSEMBL，NCBI的gtf，也导入IGV看看，截图基因结构。了解IGV常识。

### 准备工作

#### 参考基因组

测序得到的是几百bp的短read， 相当于把拼图打散了给你。如果没有参考基因组，从头(de novo)组装等于是重走人类基因组计划的老路，也就是打散了拼图，却不告诉你原来是什么样子，那么任务将会及其艰巨。 还好人类基因组已经组装好了，我们只需要把我们测得序列回贴（mapping)回去，毕竟人与人之间的差距只有不到1%差异, 允许mismatch就行。

因此第一步就是要去UCSC(<http://genome.ucsc.edu/index.html>)下载hg19参考基因组（文献要求）。![img](https://camo.githubusercontent.com/36a38abdd66557dbc0a0fcdabb7357a1ad02e7fa/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f36383830333734362e6a7067)![img](https://camo.githubusercontent.com/88e0ca0cfee3ec4af69ac4ccb131812cc4c9c006/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f35363135353938312e6a7067)![img](https://camo.githubusercontent.com/64abcdbd34018be5163820f3c4bdc578e144c622/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38313834303035382e6a7067)![img](https://camo.githubusercontent.com/d48796811838977b0fb69f700e65d5f9c3b93a71/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f39313132343639342e6a7067) 不同文件的所包含的数据在该页面有介绍，其中

> **chromFa.tar.gz** - The assembly sequence in one file per chromosome.Repeats from RepeatMasker and Tandem Repeats Finder (with period of 12 or less) are shown in lower case; non-repeating sequence is shown in upper case.

我将数据存放在Windows的F盘的Data文件夹下，用于后续操作

```
cd /mnt/f/Data
mkdir reference && cd reference
mkdir -p genome/hg19 && cd genome/hg19
nohup wget http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz &
tar -zxvf chromFa.tar.gz
cat *.fa > hg19.fa
rm chr*
```

> 这样得到的`hg19.fa`与`hg19.2bit`经twoBitToFa程序转换而成的`hg19.fa`有什么区别？？
>
> 测试结果好尴尬：
>
```shell
diff hg19.fa "/media/diviner-wsx/TOSHIBA EXT/WangShixiang/datasets/hg19/hg19.fa"
diff: memory exhausted
```
> ——shixiang

下面的内容是Jimmy在[【直播】我的基因组（五）:测试数据及参考基因组的准备](http://www.bio-info-trainee.com/1985.html)关于参考基因组的介绍。

> 这个对新手来说，是一个很大的坑，hg19、GRCH37、 ensembl 75这3种基因组版本应该是大家见得比较多的了，国际通用的人类参考基因组，其实他们储存的是同样的fasta序列，只是分别对应着三种国际生物信息学数据库资源收集存储单位，即NCBI，UCSC及ENSEMBL各自发布的基因组信息而已。有一些参考基因组比较小众，存储的序列也不一样，比如BGI做的炎黄基因组，还有DNA双螺旋结构提出者沃森（Watson）的基因组，还有2016年发表在nature上面的号称最完善的韩国人做的基因组。前期我们先不考虑这些小众基因组，主要就下载hg19和hg38，都是UCSC提供的，虽然hg38相比hg19来说，做了很多改进，优点也不少，但因为目前为止很多注释信息都是针对于hg19的坐标系统来的，我们就都下载了，正好自己探究一下。也顺便下载一个小鼠的最新版参考基因组吧，反正比对也就是睡个觉的功夫，顺便分析一下结果，看看比对率是不是很低。

**吐槽**： Jimmy大神的博客排版真的是非常考验我们对知识的渴望，每当看到他的排版的时候，我必须得忍住不去点击浏览器右上角。为了求知，我忍了。（哈哈，我也是~）

#### 注释信息

然而参考基因组是一部无字天书，要想解读书中的内容，需要额外的注释信息协助。 因此第二步，就是去gencode数据库(<http://www.gencodegenes.org/>)下载基因组注释文件。
![img](https://camo.githubusercontent.com/365bef90724ac80ec1acf90c06cb13194f09a1f3/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33353837303234312e6a7067)

看了下面这个图，我才明白Jimmy为什么会吐槽[基因组各种版本对应关系](http://www.bio-info-trainee.com/1469.html)了。 [![img](https://camo.githubusercontent.com/9c1ab8983762a4ab2d1ab2c5a825d66b15eacbe7/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38393037343530382e6a7067)](https://camo.githubusercontent.com/9c1ab8983762a4ab2d1ab2c5a825d66b15eacbe7/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38393037343530382e6a7067)

又到了GTF还是GFF3的抉择时刻，简单介绍了一下他们的格式 [![img](https://camo.githubusercontent.com/b631628af82ea8c93fb8777870dc1dbff83fa6b5/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f39373338323839352e6a7067)](https://camo.githubusercontent.com/b631628af82ea8c93fb8777870dc1dbff83fa6b5/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f39373338323839352e6a7067)

GTF（General Transfer Format）其实就是GFF2，以Tab分割，分为如下几列

1. **seqname** - name of the chromosome or scaffold; chromosome names can be given with or without the 'chr' prefix. **Important note**: the seqname must be one used within Ensembl, i.e. a standard chromosome name or an Ensembl identifier such as a scaffold ID, without any additional content such as species or assembly. See the example GFF output below.
2. **source** - name of the program that generated this feature, or the data source (database or project name)
3. **feature** - feature type name, e.g. Gene, Variation, Similarity
4. **start** - Start position of the feature, with sequence numbering starting at 1.
5. **end** - End position of the feature, with sequence numbering starting at 1.
6. **score** - A floating point value.
7. **strand** - defined as + (forward) or - (reverse).
8. **frame** - One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
9. **attribute** - A semicolon-separated list of tag-value pairs, providing additional information about each feature.

而GFF3(General Feature Format)的格式如下

1. **seqid** - name of the chromosome or scaffold; chromosome names can be given with or without the 'chr' prefix. **Important note**: the seq ID must be one used within Ensembl, i.e. a standard chromosome name or an Ensembl identifier such as a scaffold ID, without any additional content such as species or assembly. See the example GFF output below.
2. **source** - name of the program that generated this feature, or the data source (database or project name)
3. **type** - type of feature. Must be a term or accession from the SOFA sequence ontology
4. **start** - Start position of the feature, with sequence numbering starting at 1.
5. **end** - End position of the feature, with sequence numbering starting at 1.
6. **score** - A floating point value.
7. **strand** - defined as + (forward) or - (reverse).
8. **phase** - One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
9. **attributes** - A semicolon-separated list of tag-value pairs, providing additional information about each feature. Some of these tags are predefined, e.g. ID, Name, Alias, Parent - see the [GFF documentation](http://gmod.org/wiki/GFF3) for more details.

看不出来有啥区别，不想纠结就全下载好了。（两种格式详细介绍(<https://mp.weixin.qq.com/s/IUc8vnE17e9BY14Ssq3nDw>)）
```shell
nohup wget ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_26/GRCh37_mapping/gencode.v26lift37.annotation.gtf.gz &
nohup wget ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_26/GRCh37_mapping/gencode.v26lift37.annotation.gff3.gz &
```

我们对文字的理解能力远远小于图片，所以下一步需要下载基因组浏览器

#### IGV， Integrative Genomics Viewer

下载地址为： <http://software.broadinstitute.org/software/igv/download> Windows下载如下版本， 会自带一个java运行环境 [![img](https://camo.githubusercontent.com/3618298837fe0bacdef72addf903c90c1ebe0340/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34313437393536372e6a7067)](https://camo.githubusercontent.com/3618298837fe0bacdef72addf903c90c1ebe0340/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34313437393536372e6a7067) 双击igv.bat， 就会出现运行界面。 [![img](https://camo.githubusercontent.com/75348e36e1eea2f7116222cf0c76d75125d7542d/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32383835383833342e6a7067)](https://camo.githubusercontent.com/75348e36e1eea2f7116222cf0c76d75125d7542d/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32383835383833342e6a7067)

通过genome -> Load Genome From Files加载之前得到基因组文件。 [![img](https://camo.githubusercontent.com/b83c986b6e9d0199ad939d23bc7160a41bdcfcab/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f37393834373834322e6a7067)](https://camo.githubusercontent.com/b83c986b6e9d0199ad939d23bc7160a41bdcfcab/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f37393834373834322e6a7067)

进一步，还需要加载gff基因注释文件，File -> Load From Files 显示未排序出错，可以使用Tool -> Run igvtools，进行排序。

![img](https://camo.githubusercontent.com/36a0c6dbcb0240396ee84f095291d9e038ac95a7/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32383930303632312e6a7067)![img](https://camo.githubusercontent.com/0af3337cf6ee94df38a7d123773b8b4d5dee6771/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33363339323132372e6a7067)

之后就可以重新加载排序后的gtf文件进行操作。生信宝典写过一篇文章介绍测序数据可视化（http://mp.weixin.qq.com/s/Q7pqycmQH58xU6hw_LECWA） 我也在看文档摸索中，先放上基因截图 [![img](https://camo.githubusercontent.com/d0b861ca6cf883718e4c11642e25101ab9505705/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33333138333236332e6a7067)](https://camo.githubusercontent.com/d0b861ca6cf883718e4c11642e25101ab9505705/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33333138333236332e6a7067)

下面这张图是来自于几个月前Jimmy对高通量测序的理解，提供数据的截图 [![img](https://camo.githubusercontent.com/0bd9fbbcb61dc43403a8469bfef04e34fac2d5f3/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f31363336313537332e6a7067)](https://camo.githubusercontent.com/0bd9fbbcb61dc43403a8469bfef04e34fac2d5f3/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f31363336313537332e6a7067)



## 序列比对

> 比对软件很多，首先大家去收集一下，因为我们是带大家入门，请统一用hisat2，并且搞懂它的用法。 直接去hisat2的主页下载index文件即可，然后把fastq格式的reads比对上去得到sam文件。 接着用samtools把它转为bam文件，并且排序(注意N和P两种排序区别)索引好，载入IGV，再截图几个基因看看！ 顺便对bam文件进行简单QC，参考直播我的基因组系列。

前面四篇基本都算是准备工作，从这一篇开始才算进入了RNA-Seq数据分析的核心部分。

## 比对

#### 比对还是不比对

在比对之前，我们得了解比对的目的是什么？RNA-Seq数据比对和DNA-Seq数据比对有什么差异？ RNA-Seq数据分析分为很多种，比如说找差异表达基因或寻找新的可变剪切。如果找差异表达基因单纯只需要确定不同的read计数就行的话，我们可以用bowtie, bwa这类比对工具，或者是salmon这类align-free工具，并且后者的速度更快。

但是如果你需要找到新的isoform，或者RNA的可变剪切，看看外显子使用差异的话，你就需要TopHat, HISAT2或者是STAR这类工具用于找到剪切位点。因为RNA-Seq不同于DNA-Seq，DNA在转录成mRNA的时候会把内含子部分去掉。所以mRNA反转的cDNA如果比对不到参考序列，会被分开，重新比对一次，判断中间是否有内含子。 [![img](https://camo.githubusercontent.com/75bcb01635590fba86daf07c384f73c0f26eb27a/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34373932333739342e6a7067)](https://camo.githubusercontent.com/75bcb01635590fba86daf07c384f73c0f26eb27a/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34373932333739342e6a7067)

#### 工具抉择

在2016年的一篇综述_A survey of best practices for RNA-seq data analysis_，提到目前有三种RNA数据分析的策略。那个时候的工具也主要用的是**TopHat**,**STAR**和**Bowtie**.其中**TopHat**目前已经被它的作者推荐改用**HISAT**进行替代。 [![img](https://camo.githubusercontent.com/1d4de6792d69ad593e30a9415a05b6de16158444/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38393835303334372e6a7067)](https://camo.githubusercontent.com/1d4de6792d69ad593e30a9415a05b6de16158444/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38393835303334372e6a7067) 最近的Nature Communication发表了一篇题为的_Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis_的文章--被称之为史上最全RNA-Seq数据分析流程，也是我一直以来想做的事情，只不过他们做的超乎我的想象。文章中在基于参考基因组的转录本分析中所用的工具，是TopHat,HISAT2和STAR，**结论**就是HISAT2**找到junction正确率**最高，但是在总数上却比TopHat和STAR少。从这里可以看出HISAT2的二类错误(**纳伪**）比较少，但是一类错误（**弃真**）就高起来。 就**唯一比对**而言，**STAR是三者最佳的**，主要是因为**它不会像TopHat和HISAT2一样在PE比对不上的情况还强行把SE也比对到基因组上**。而且在处理较长的read和较短read的不同情况，STAR的稳定性也是最佳的。 就**速度**而言，HISAT2比STAR和TopHat2平均快上2.5~100倍。 [![img](https://camo.githubusercontent.com/981ed6e8051d340fb8e195c44616a001c57324bf/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38343034343632332e6a7067)](https://camo.githubusercontent.com/981ed6e8051d340fb8e195c44616a001c57324bf/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38343034343632332e6a7067)

如果学习RNA-Seq数据分析，上面提到的两篇文献是必须要看上3遍以上的，而且建议每隔一段时间回顾一下。但是**如果就比对工具而言，基本上就是HISAT2和STAR选一个就行**。

#### 下载index

首先，问自己一个问题，为什么比对的时候需要用到index？这里强烈建议大家去看Jimmy写的[bowtie算法原理探究bowtie算法原理探究](http://www.biotrainee.com/thread-26-1-1.html)。但是只是建议，你不需要真的去看，反正你也看不懂。

高通量测序遇到的第一个问题就是，成千上万甚至上几亿条read如果在合理的时间内比对到参考基因组上，并且保证错误率在接受范围内。为了提高比对速度，就需要根据参考基因组序列，经过BWT算法转换成index，而我们比对的序列其实是index的一个子集。当然转录组比对还要考虑到可变剪切的情况，所以更加复杂。

因此**我们不是直接把read回贴到基因组上，而是把read和index进行比较**。人类的index一般都是有现成的，我建议大家下载现成的，我曾经尝试过用服务器自己创建index，花的时间让我怀疑人生。

![img](https://camo.githubusercontent.com/f8679f29f94da8f056f3d251cddf85368338f294/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f35323536363331322e6a7067)

```
cd referece && mkdir index && cd index
wget ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/data/hg19.tar.gz
tar -zxvf hg19.tar.gz
```

觉得电脑配置还行的，或者是没有现成index的，可以通过HISAT2的方法进行创建

```
# 其实hisat2-buld在运行的时候也会自己寻找exons和splice_sites，但是先做的目的是为了提高运行效率
extract_exons.py gencode.v26lift37.annotation.sorted.gtf > hg19.exons.gtf &
extract_splice_sites.py gencode.v26lift37.annotation.gtf > hg19.splice_sites.gtf &
# 建立index， 必须选项是基因组所在文件路径和输出的前缀
hisat2-build --ss hg19.splice_sites.gtf --exon hg19.exons.gtf genome/hg19/hg19.fa hg19
```

我的是i7-7700处理器，内存是64G，运行的资源效率如下： [![img](https://camo.githubusercontent.com/2f37a4611211258e939ddfdde4c37855ae612742/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38363534333037362e6a7067)](https://camo.githubusercontent.com/2f37a4611211258e939ddfdde4c37855ae612742/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38363534333037362e6a7067)

#### 正式比对

(**这里有坑，先看输出结果部分**，这里实际使用的是56,57,58。了解下坑不是什么坏事)

hisat2基本用法就是`hisat2 [options]* -x <hisat2-idx> {-1 <m1> -2 <m2> | -U <r> } [-S <hit>]`，基本就是提供index的位置，PE数据或者是SE数据存放位置。然而其他可选参数却是进阶的一大名堂。新手就用默认参数呗。

因为RNA-Seq数据是从 SRR3589957 ~ SRR3589962，6个样本的PE数据，也就是有6次循环，可以写脚本，也可以直接在命令行里运行 如下命令运行所在目录为`/mnt/f/Data/`，我的参考基因组的index数据存放在`/mnt/f/Data/reference/index/hg19/`，而RNA-seq数据存放在`/mnt/f/Data/RNA-Seq`下。比对结果会存放在`/mnt/f/Data/RNA-Seq/aligned`

```shell
mkdir -p RNA-Seq/aligned
for i in `seq 57 62`
do
    hisat2 -t -x reference/index/hg19/genome -1 RNA-Seq/SRR35899${i}_1.fastq.gz -2 SRR35899${i}_2.fastq.gz -S RNA-Seq/aligned/SRR35899${i}.sam &
done
```

`&`会把任务丢到后台，所以会同时执行这3个比对程序，如果CPU和内存承受不住，去掉`&`一个个来。比对这一步是非常消耗内存资源的，这是比对工具要将索引数据放入内存引起的。我有64G内存，理论上可以同时处理20个PE数据。在我的电脑配置下，大致花了2个小时同时才完成这一步. [![img](https://camo.githubusercontent.com/f9ca778a168d90a649e09be00b757e5ad31ed006/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33353235333830362e6a7067)](https://camo.githubusercontent.com/f9ca778a168d90a649e09be00b757e5ad31ed006/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33353235333830362e6a7067)

#### 基本参数说明

在数据比对的时候，可以安静一下读读HISAT2的额外选项，主要分为如下几块

- 主要参数，一定要填写的内容
- 输入选项， 对结果影响不大
- 比对选项，主要是`--n-ceil`决定模糊字符的数量
- 得分选项， 当一个read比对到不同部位时，确定那个才是最优的。基于mismatch, soft-cliping, gap得分。
- 可变剪切比对选项， 你要决定exon，intron的长度，GT/AG的得分，还可以提供已知的可变剪切和外显子gtf文件，
- 报告选项，确定要找多少的位置
- PE选项， 与gap有关的参数
- 输出选项，建议加上-t记录时间，其他就是压缩格式，不影响比对
- SAM选项， 主要是决定SAM的header应该添加哪些内容
- 性能选项和其他选项不考虑

**注**: *soft clipping* 指的是比对的read只有部分匹配到参考序列上，还有部分没有匹配上。也就是一个100bp的read，就匹配上前面20 bp或者是后面20bp，或者是后面20bp比对的效果不太好。

因此影响比对结果就是**比对选项**，**得分选项**，**可变剪切选项**和**PE选项**，在有生之年我应该会写一片文章介绍这些选项对结果的影响。

#### HISAT2输出结果

比对之后会输出如下结果，解读一下就是全部数据都是100%的，96.68%的配对数据一次都没有比对，1.23%的数据比是唯一比对，2.09%是多个比对。然后96.68%一次都没有比对的数据，如果不按照顺序来，有0.05%的比对。之后把剩下的部分用单端数据进行比对的话，95.20%数据没比对上，3.60%的数据比对一次，1.20%比对超过一次。零零总总的加起来是8%的比对！！！ [![img](https://camo.githubusercontent.com/6e1404bbbdb368f4fd4e3d23b0066a2c5ad1421f/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f36313533303432352e6a7067)](https://camo.githubusercontent.com/6e1404bbbdb368f4fd4e3d23b0066a2c5ad1421f/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f36313533303432352e6a7067)

这个总体比对率让我开始怀疑人生，怎么可能呀，我翻了翻输出记录，发现有几个结果的比对率超过90%呀。我思索了片刻，惊醒这个实验好像是用人类和小鼠都做了一遍。于是又去GEO上查了一下记录，恍然大悟，差点翻车。

> Samples 9-15 are mRNA-seq to determine effect of AKAP95 knockdown in human 293 cells (9-11) or mouse ES cells (12-15).

[![img](https://camo.githubusercontent.com/f76e17d43706b3a5abf9a91efa91135539849f14/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f39363931333239302e6a7067)](https://camo.githubusercontent.com/f76e17d43706b3a5abf9a91efa91135539849f14/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f39363931333239302e6a7067)

同时我反思了一下出错的**原因**，我默认这个实验是KO和非KO各3个重复，其实文章的实验设计并不是如此，可见理解实验设计很重要，于是我把数据下载这一部分进行了完善。

下面是修改后的代码

```
mkdir -p RNA-Seq/aligned
for i in `seq 56 58`
do
    hisat2 -t -x reference/index/hg19/genome -1 RNA-Seq/SRR35899${i}_1.fastq.gz -2 SRR35899${i}_2.fastq.gz -S RNA-Seq/SRR35899${i}.sam &
done
```



### SAMtools三板斧

SAM（sequence Alignment/mapping)数据格式是目前高通量测序中存放比对数据的标准格式，当然他可以用于存放未比对的数据。所以，[SAM的格式说明](https://samtools.github.io/hts-specs/SAMv1.pdf) 。

而目前处理SAM格式的工具主要是SAMTools，这是Heng Li大神写的。除了C语言版本，还有Java的Picard，Python的Pysam，Common lisp的cl-sam等其他版本。SAMTools的主要功能如下：

- **view**: BAM-SAM/SAM-BAM 转换和提取部分比对
- **sort**: 比对排序
- **merge**: 聚合多个排序比对
- **index**: 索引排序比对
- **faidx**: 建立FASTA索引，提取部分序列
- [**tview**](http://samtools.sourceforge.net/tview.shtml): 文本格式查看序列
- [**pileup**](http://samtools.sourceforge.net/pileup.shtml): 产生基于位置的结果和 [consensus/indel calling](http://samtools.sourceforge.net/cns0.shtml)

最常用的三板斧就是格式**转换，排序，索引**。而进阶教程就是看文档提高。

```shell
for i in `seq 56 58`
do
    samtools view -S SRR35899${i}.sam -b > SRR35899${i}.bam
    samtools sort SRR35899${i}.bam -o SRR35899${i}_sorted.bam
    samtools index SRR35899${i}_sorted.bam
done
```

**注**

- -S是最新版samtools为了兼容以前版本写的，所以可以省去
- 0.1.19版本和最新版有比较大差别，请注意版本

Jimmy说样我们仔细判断sam排序两种方式的不同，因此我截取前面100行数据，分别排序然后查看结果。

```shell
head -1000 SRR3589957.sam > test.sam
samtools view -b  test.sam > test.bam
samtools view test.bam | head
```

[![img](https://camo.githubusercontent.com/99894dc564f1b3c51ffcd820457fb34bc5df9fcc/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f31303638353136312e6a7067)](https://camo.githubusercontent.com/99894dc564f1b3c51ffcd820457fb34bc5df9fcc/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f31303638353136312e6a7067)

默认排序是根据染色体位置

```shell
samtools sort test.bam default
samtools view default.bam | head
```

[![img](https://camo.githubusercontent.com/7e065c4624c006c097d910284528df4da7c08b88/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33353231343030362e6a7067)](https://camo.githubusercontent.com/7e065c4624c006c097d910284528df4da7c08b88/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f33353231343030362e6a7067)

Sort alignments by leftmost coordinates, or by read name when -n is used.

```shell
samtools sort -n test.bam sort_left
samtools view sort_left.bam | head
```

[![img](https://camo.githubusercontent.com/afefba36de4c62ebaf7db5d976d0c65cc99f3af4/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32373133343136352e6a7067)](https://camo.githubusercontent.com/afefba36de4c62ebaf7db5d976d0c65cc99f3af4/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32373133343136352e6a7067)

也就是说默认按照染色体位置进行排序，而`-n`参数则是根据read名进行排序。当然还有一个`-t` 根据TAG进行排序。

#### 说说samtools view

三板斧的`view`是一个非常实用的子命令，除了之前的格式转换以外，还能进行数据提取。 比如说**提取**1号染色体1234-123456区域的比对read

```
samtools view SRR3589957_sorted.bam chr1:1234-123456 | head
```

[![img](https://camo.githubusercontent.com/afefba36de4c62ebaf7db5d976d0c65cc99f3af4/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32373133343136352e6a7067)](https://camo.githubusercontent.com/afefba36de4c62ebaf7db5d976d0c65cc99f3af4/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32373133343136352e6a7067)在比如搭配`flag`(0.1.19版本没有）和`flagstat`，使用`-f`或`-F`参数提取不同匹配情况的read。 flag是一种描述read比对情况的标记，一种12种，可以搭配使用。

```shell
0x1    PAIRED    paired-end (or multiple-segment) sequencing technology
0x2    PROPER_PAIR    each segment properly aligned according to the aligner
0x4    UNMAP    segment unmapped
0x8    MUNMAP    next segment in the template unmapped
0x10    REVERSE    SEQ is reverse complemented
0x20    MREVERSE    SEQ of the next segment in the template is reverse complemented
0x40    READ1    the first segment in the template
0x80    READ2    the last segment in the template
0x100    SECONDARY    secondary alignment
0x200    QCFAIL    not passing quality controls
0x400    DUP    PCR or optical duplicate
0x800    SUPPLEMENTARY    supplementary alignment
```

可以先用flagstat看下总体情况

```shell
samtools flagstat SRR3589957_sorted.bam
```

[![img](https://camo.githubusercontent.com/6582ee54efdece40bc17521ee37f820058fc0651/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32363236363933322e6a7067)](https://camo.githubusercontent.com/6582ee54efdece40bc17521ee37f820058fc0651/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f32363236363933322e6a7067)

也就是说如果我想用samtools筛选恰好配对的read,就需要用0x10

```shell
samtools view -b -f 0x10 SRR3589957_sorted.bam chr1:1234-123456  > flag.bam
samtools flagstat flag.bam
```

我应该会在有生之年写一篇文章好好介绍samtools。

### 比对质控(QC)

还是在_A survey of best practices for RNA-seq data analysis_里面，提到了人类基因组应该有70%~90%的**比对率**，并且多比对read（multi-mapping reads）数量要少。另外比对在外显子和所比对链（uniformity of read coverage on exons and the mapped strand）的覆盖度要保持一致。

常用工具有

- Picard <https://broadinstitute.github.io/picard/>
- RSeQC <http://rseqc.sourceforge.net/>
- Qualimap <http://qualimap.bioinfo.cipf.es/>

我们就用RSeQC吧，毕竟使用python写的工具，天生的亲切感，而且安装非常方便。

```shell
# Python2.7环境下
pip install RSeQC
```

一共有如下几个文件，根据命名就知道功能是啥了。

- [bam2fq.py](http://rseqc.sourceforge.net/#bam2fq-py)
- [bam2wig.py](http://rseqc.sourceforge.net/#bam2wig-py)
- [bam_stat.py](http://rseqc.sourceforge.net/#bam-stat-py)
- [clipping_profile.py](http://rseqc.sourceforge.net/#clipping-profile-py)
- [deletion_profile.py](http://rseqc.sourceforge.net/#deletion-profile-py)
- [divide_bam.py](http://rseqc.sourceforge.net/#divide-bam-py)
- [FPKM_count.py](http://rseqc.sourceforge.net/#fpkm-count-py)
- [geneBody_coverage.py](http://rseqc.sourceforge.net/#genebody-coverage-py)
- [geneBody_coverage2.py](http://rseqc.sourceforge.net/#genebody-coverage2-py)
- [infer_experiment.py](http://rseqc.sourceforge.net/#infer-experiment-py)
- [inner_distance.py](http://rseqc.sourceforge.net/#inner-distance-py)
- [insertion_profile.py](http://rseqc.sourceforge.net/#insertion-profile-py)
- [junction_annotation.py](http://rseqc.sourceforge.net/#junction-annotation-py)
- [junction_saturation.py](http://rseqc.sourceforge.net/#junction-saturation-py)
- [mismatch_profile.py](http://rseqc.sourceforge.net/#mismatch-profile-py)
- [normalize_bigwig.py](http://rseqc.sourceforge.net/#normalize-bigwig-py)
- [overlay_bigwig.py](http://rseqc.sourceforge.net/#overlay-bigwig-py)
- [read_distribution.py](http://rseqc.sourceforge.net/#read-distribution-py)
- [read_duplication.py](http://rseqc.sourceforge.net/#read-duplication-py)
- [read_GC.py](http://rseqc.sourceforge.net/#read-gc-py)
- [read_hexamer.py](http://rseqc.sourceforge.net/#read-hexamer-py)
- [read_NVC.py](http://rseqc.sourceforge.net/#read-nvc-py)
- [read_quality.py](http://rseqc.sourceforge.net/#read-quality-py)
- [RNA_fragment_size.py](http://rseqc.sourceforge.net/#rna-fragment-size-py)
- [RPKM_count.py](http://rseqc.sourceforge.net/#rpkm-count-py)
- [RPKM_saturation.py](http://rseqc.sourceforge.net/#rpkm-saturation-py)
- [spilt_bam.py](http://rseqc.sourceforge.net/#spilt-bam-py)
- [split_paired_bam.py](http://rseqc.sourceforge.net/#split-paired-bam-py)
- [tin.py](http://rseqc.sourceforge.net/#tin-py)

先对bam文件进行统计分析， 从结果上看是符合70~90的比对率要求。

```
bam_stat.py -i SRR3589956_sorted.bam

```

[![img](https://camo.githubusercontent.com/9486696df5988ab40ff1212bb859c829a771ddb1/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34353935393039302e6a7067)](https://camo.githubusercontent.com/9486696df5988ab40ff1212bb859c829a771ddb1/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f34353935393039302e6a7067)

基因组覆盖率的QC需要提供bed文件，可以直接RSeQC的网站下载，或者可以用gtf转换

```
read_distribution.py -i RNA-Seq/aligned/SRR3589956_sorted.bam -r reference/hg19_RefSeq.bed

```

[![img](https://camo.githubusercontent.com/f4a6f375d9b1a17ebd64960d3c77a246fa3b9b0c/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38303831313330322e6a7067)](https://camo.githubusercontent.com/f4a6f375d9b1a17ebd64960d3c77a246fa3b9b0c/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38303831313330322e6a7067)

### IGV查看

载入参考序列，注释和BAM文件，随便看看吧。

[![img](https://camo.githubusercontent.com/70fb2d7cc1aed5c8269834c97d0582900d532da6/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f363131393437322e6a7067)](https://camo.githubusercontent.com/70fb2d7cc1aed5c8269834c97d0582900d532da6/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f363131393437322e6a7067)



## reads计数

### 要求

> 实现这个功能的软件也很多，还是烦请大家先自己搜索几个教程，入门请统一用htseq-count，对每个样本都会输出一个表达量文件。 需要用脚本合并所有的样本为表达矩阵。参考：生信编程直播第四题：多个同样的行列式文件合并起来 对这个表达矩阵可以自己简单在excel或者R里面摸索，求平均值，方差。 看看一些生物学意义特殊的基因表现如何，比如GAPDH,β-ACTIN等等。

### 理论基础

在上篇的比对中，我们需要纠结是否真的需要比对，如果你只需要知道已知基因的表达情况，那么可以选择alignment-free工具（例如salmon, sailfish)，如果你需要找到noval isoforms，那么就需要alignment-based工具（如HISAT2, STAR）。到了这一篇的基因（转录本）定量，需要考虑的因素就更加多了，以至于我不知道如何说清才能理清逻辑。

定量分为三个水平

- 基因水平(gene-level)
- 转录本水平(transcript-level)
- 外显子使用水平(exon-usage-level)。

在**基因水平**上，常用的软件为HTSeq-count，featureCounts，BEDTools, Qualimap, Rsubread, GenomicRanges等。以常用的HTSeq-count为例，这些工具要解决的问题就是根据read和基因位置的overlap判断这个read到底是谁家的孩子。值得**注意**的是不同工具对multimapping reads处理方式也是不同的，例如HTSeq-count就直接当它们不存在。而Qualimpa则是一人一份，平均分配。

[![_images/count_modes.png](https://camo.githubusercontent.com/3c288240c69aa17bea5b7652778cf7469b221e09/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38313937373035392e6a7067)](https://camo.githubusercontent.com/3c288240c69aa17bea5b7652778cf7469b221e09/687474703a2f2f6f6578373530677a742e626b742e636c6f7564646e2e636f6d2f31372d372d31392f38313937373035392e6a7067)

对每个基因计数之后得到的count matrix再后续的分析中，要注意标准化的问题。如果你要比较同一个样本(within-sample)不同基因之间的表达情况，你就需要考虑到**转录本长度**，因为转录本越长，那么检测的片段也会更多，直接比较等于让小孩和大人进行赛跑。如果你是比较不同样本（across sample）同一个基因的表达情况，虽然不必在意转录本长度，但是你要考虑到**测序深度**（sequence depth)，毕竟测序深度越高，检测到的概率越大。除了这两个因素外，你还需要考虑GC%所导致的偏差，以及测序仪器的系统偏差。目前对read count标准化的算法有RPKM（SE）, FPKM（PE），TPM, TMM等，不同算法之间的差异与换算方法已经有文章进行整理和吐槽了。**但是**，有一些下游分析的软件会要求是输入的count matrix是原始数据，未经标准化，比如说DESeq2，这个时候你需要**注意**你上一步所用软件会不会进行标准化。

在**转录本水平**上，一般常用工具为Cufflinks和它的继任者StringTie， eXpress。这些软件要处理的难题就时转录本亚型（isoforms）之间通常是有重叠的，当二代测序读长低于转录本长度时，如何进行区分？这些工具大多采用的都是expectation maximization（EM）。好在我们有三代测序。

上述软件都是alignment-based，目前许多alignment-free软件，如kallisto, silfish, salmon，能够省去比对这一步，直接得到read count，在运行效率上更高。不过最近一篇文献[1]指出这类方法在估计丰度时存在样本特异性和读长偏差。

在**外显子使用水平**上，其实和基因水平的统计类似。但是值得注意的是为了更好的计数，我们需要提供无重叠的外显子区域的gtf文件[2]。用于分析差异外显子使用的DEXSeq提供了一个Python脚本（dexseq_prepare_annotation.py）执行这个任务。

#### 小结

计数分为三个水平： gene-level, transcript-level, exon-usage-level

标准化方法： FPKM RPKM TMM TPM

### 输出表达矩阵

在RNA-Seq分析中，每一个基因就是一个feature（特征？），而基因被认为是它的所有外显子的和集。在可变剪切分析中，可以单独把每个外显子当作一个feature。而在ChIP-Seq分析中，feature则是预先定义的结合域。但是确定一个read到底属于哪一个feature有时会非常棘手。因此HTSeq提供了三种模式，示意图见前一幅图

- the union of all the sets S(i) for mode union. This mode is recommended for most use cases.
- the intersection of all the sets S(i) for mode intersection-strict.
- the intersection of all non-empty sets S(i) for mode intersection-nonempty.

基本用法非常的简单：

```
# 安装
conda install htseq
# 使用
# htseq-count [options] <alignment_file> <gtf_file>
htseq-count -r pos -f bam RNA-Seq/aligned/SRR3589957_sorted.bam reference/gencode.v26lift37.annotation.sorted.gtf > SRR3589957.count
```

用一个循环处理多个BAM文件(在/mnt/f/Data目录下)

```
mkdir -p RNA-Seq/matrix/
for i in `seq 56 58`
do
    htseq-count -s no -r pos -f bam RNA-Seq/aligned/SRR35899${i}_sorted.bam reference/gencode.v26lift37.annotation.sorted.gtf > RNA-Seq/matrix/SRR35899${i}.count 2> RNA-Seq/matrix/SRR35899${i}.log
done
```

运行的时间会比较久，所以可以去了解不同参数的用法了，其中比较常用的为：

- -f bam/sam： 指定输入文件格式，默认SAM
- -r name/pos: 你需要利用samtool sort对数据根据read name或者位置进行排序，默认是name
- -s yes/no/reverse: 数据是否来自于strand-specific assay。DNA是双链的，所以需要判断到底来自于哪条链。如果选择了no， 那么每一条read都会跟正义链和反义链进行比较。默认的yes对于双端测序表示第一个read都在同一个链上，第二个read则在另一条链上。
- -a 最低质量， 剔除低于阈值的read
- -m 模式 union（默认）, intersection-strict and intersection-nonempty。一般而言就用默认的，作者也是这样认为的。
- -i id attribute: 在GTF文件的最后一栏里，会有这个基因的多个命名方式（如下）， RNA-Seq数据分析常用的是gene_id， 当然你可以写一个脚本替换成其他命名方式。

> gene_id "ENSG00000223972.5_2"; transcript_id "ENST00000456328.2_1"; gene_type "transcribed_unprocessed_pseudogene"; gene_name "DDX11L1"; transcript_type "processed_transcript"; transcript_name "DDX11L1-002"; exon_number 2; exon_id "ENSE00003582793.1_1"; level 2;...

#### Jimmy的伏笔

我们这次分析是人类mRNA-Seq测序的结果，但是我们其实只下载了3个sra文件。一般而言RNA-Seq数据分析都至少要有2个重复，所以必须要有4个sra文件才行。我在仔细读完文章的方法这一段以后，发现他们有一批数据用的是其他课题组的： For 293 cells, the mRNA-seq results of the control samples include (1) those from the doxycycline-treated parental Flp-In T-REx 293 cells by us and (2) those from the doxycycline-treated control Flp-In T-REx 293 cells performed by another group unrelated to us (sample GSM1095127 in GSE44976)。 然后和Jimmy交流之后，他也承认自己只分析了小鼠的数据，而没有分析人类的数据。所以我们需要根据文章提供的线索下载另外一份数据，才能进行下一步的分析。

这个时候就有一个经常被问到的问题：不同来源的RNA-Seq数据能够直接比较吗？甚至说如果不同来源的RNA-seq数据的构建文库都不一样该如何比较?不同来源的RNA-Seq结果之间比较需要考虑 **批次效应（batch effect)** 的影响。

处理批次效应，根据我搜索的结果，是不能使用FPKM/RPKM，关于这个标准化的吐槽，我在biostars上找到了如下观点：

- FPKM/RPKM 不是标准化的方法，它会引入文库特异的协变量
- FPKM/RPKM has never been peer-reviewed, it has been introduced as an ad-hoc measure in a supplementary 没有同行评审
- One of the authors of this paper states, that it should not be used because of faulty arithmetic 作者说算法有问题
- All reviews so far have shown it to be an inferior scale for DE analysis of genes Length normalization is mostly dispensable imo in DE analysis because gene length is constant

有人建议使用一个Bioconductor包<http://www.bioconductor.org/packages/devel/bioc/html/sva.html> 我没有具体了解，有生之年去了解补充。

还有人引用了一篇文献 IVT-seq reveals extreme bias in RNA-sequencing 证明不同文库的RNA-Seq结果会存在很大差异。

**结论**： 可以问下原作者他们是如何处理数据的，居然有一个居然没有重复的分析也能过审。改用小鼠数据进行分析。或者使用无重复的分析方法，或者模拟一份数据出来，先把流程走完。

### 合并表达矩阵

HTSeq-count输出结果是一个个独立的文件，后续分析需要把多个文件合并成一个行为基因名，列为样本名，中间为count的行列式文件。肯定是不会用Excel手动处理（虽然可以写一个VBA脚本，但是数据量过大不好处理了），这里使用的Python写一个脚本。

基本逻辑：

1. 读取文件
2. 建立一个字典，如果key不在字典中，新增key和value，如果key在字典中，追加value。
3. 输出

```
#!/usr/bin/python3

import sys
mydict = {}
for file in sys.argv[1:]:
    for line in open(file, 'r'):
        key,value = line.strip().split('\t')
        if key in mydict:
            mydict[key] = mydict[key] + '\t' + value
        else:
            mydict[key] = value

for key,value in mydict.items():
    print(key + '\t' + value +'\n')

```

> 这几行代码写了2个番茄钟，但是debug花了我一个番茄钟。问题出在str和list两种数据格式的混乱使用。还有一个bug： 由于词典是无序的，所以原本代表样本来源的第一行，会跑到其他行。 在论坛上找到一个更加简洁的代码（要求基因名顺序排列），用到`paste`, `awk`, `printf`这三个shell命令。

```
paste *.txt | awk '{printf $1 "\t";for(i=2;i<=NF;i+=2) printf $i"\t";printf $i}'

```

保存为countCombiner.py，输入文件为count, 输出为标准输出，需要重定向。

### 简单分析

这一步需要用到R语言或者是Excel读取数据。

1.导入数据

```
options(stringsAsFactors = FALSE)
# import data if sample are small
control <- read.table("F:/Data/RNA-Seq/matrix/SRR3589956.count",
                       sep="\t", col.names = c("gene_id","control"))
rep1 <- read.table("F:/Data/RNA-Seq/matrix/SRR3589957.count",
                    sep="\t", col.names = c("gene_id","rep1"))
rep2 <- read.table("F:/Data/RNA-Seq/matrix/SRR3589958.count",
                    sep="\t",col.names = c("gene_id","rep2"))
```

2.数据整合。gencode的注释文件中的gene_id（如ENSG00000105298.13_3）在EBI是不能搜索到的，所以我就只保留ENSG00000105298这部分。

```
# merge data and delete the unuseful row
raw_count <- merge(merge(control, rep1, by="gene_id"), rep2, by="gene_id")
raw_count_filt <- raw_count[-1:-5,]
ENSEMBL <- gsub("(.*?)\\.\\d*?_\\d", "\\1", raw_count_filt$gene_id)
row.names(raw_count_filt) <- ENSEMBL

```

3.总体情况, 大部分基因都为0，所以可以删掉节省体积。

```
summary(raw_count_filt)
    control              rep1               rep2         
 Min.   :     0.0   Min.   :     0.0   Min.   :     0.0  
 1st Qu.:     0.0   1st Qu.:     0.0   1st Qu.:     0.0  
 Median :     0.0   Median :     0.0   Median :     0.0  
 Mean   :   356.1   Mean   :   370.3   Mean   :   316.6  
 3rd Qu.:    15.0   3rd Qu.:    15.0   3rd Qu.:    10.0  
 Max.   :161867.0   Max.   :121902.0   Max.   :105565.0  
```

4.看几个具体基因 在EBI上搜索GAPDH找到ID为ENSG00000111640。

```
GAPDH <- raw_count_filt[rownames(raw_count_filt)=="ENSG00000111640",]
                             gene_id control  rep1  rep2
ENSG00000111640 ENSG00000111640.14_2   41857 53902 55302

```

文章研究的AKAP95（ENSG00000105127）的表达量在KD中都降低了

```
> AKAP95 <- raw_count_filt[rownames(raw_count_filt)=="ENSG00000105127",]
> AKAP95
                            gene_id control rep1 rep2
ENSG00000105127 ENSG00000105127.8_2    1168  539  506

```

下面的差异基因表达，让我想想，该如何收拾Jimmy挖的坑。

### 参考文献

> [1] Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis
>
> [2] Detecting differential usage of exons from RNA-seq data
>
> [3] RNA-seq Data Analysis-A Practical Approach(2015)